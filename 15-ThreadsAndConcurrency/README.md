# 线程与并发

目前为止，我们只看到过像一匹马一样在跑道上奔跑的程序。

但是把一个程序的主任务切分成更小的任务（我们称它们为子任务）通常是很有用的。

想想一个蚁群，在那里有大量的工蚁协同工作，完成蚁后让它们做的事。每一群蚂蚁都是独立任务的一部分，各自完成自己的工作。

编程中**并发**的概念与蚁群的本质非常相似。

### 01：并发任务：继承Thread

在Java中，可以使用线程并行地运行任务。先写个简单的程序。

##### Snippet-1

***ThreadBasicsRunner.java***

```java
public class ThreadBasicsRunner {
  public static void main(String[] args) {
    //Task1
    for(int i=101; i<=199; i++) {
      System.out.print(i + " ");
    }
    System.out.println("\n Task1 Done");

    //Task2
    for(int i=201; i<=299; i++) {
      System.out.print(i + " ");
    }

    System.out.println("\n Task2 Done");
    //Task3
    for(int i=301; i<=399; i++) {
      System.out.print(i + " ");			
    }
    System.out.println("\n Task3 Done");

    System.out.println("Main Done");
  }
}
```

***控制台输出***

*101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199*

*Task1 Done*

*201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299*

*Task2 Done*

*301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399*

*Task3 Done*

*Main Done*

##### Snippet-1 说明

正如你所看到的的，这三个`for`循环（实际上独立的任务）的执行是连续的。到目前为止，我们所有的代码都是这样运行。

### 线程创建

在一个程序中，有两种方法可以创建线程来表示子任务。它们是：

- 定义你自己的线程类作为**`Thread`**类的子类
- 定义你自己的实现了**`Runnable`**接口的线程类

在这一节中，我们将集中讨论第一种选择。

##### Snippet-01：一个简单的Java线程类

***ThreadBasicsRunner.java***

```java
class Task1 extends Thread {
  public void run() {
    System.out.println("Task1 Started ");
    for(int i=101; i<=199; i++) {
      System.out.print(i + " ");
    }
    System.out.println("\nTask1 Done");
  }	
}

public class ThreadBasicsRunner {
  public static void main(String[] args) {
    //Task1
    Task1 task1 = new Task1();
    task1.start();

    //Task2
    for(int i=201; i<=299; i++) {
      System.out.print(i + " ");
    }
    System.out.println("\nTask2 Done");

    //Task3
    for(int i=301; i<=399; i++) {
      System.out.print(i + " ");
    }
    System.out.println("\nTask3 Done");
    System.out.println("\nMain Done");
  }	
}
```

***控制台输出***

```
Task1 Started 
201 101 202 102 203 103 204 104 105 205 206 106 207 107 208 108 209 109 210 110 211 111 212 112 213 113 214 114 215 115 216 116 217 218 117 219 118 220 119 221 120 222 121 122 223 123 224 124 225 125 226 126 227 127 228 128 229 129 230 130 231 131 232 132 233 133 234 134 235 135 236 136 237 137 238 138 239 139 240 140 241 141 242 142 243 143 244 144 245 145 246 247 146 248 147 249 148 250 149 251 150 252 151 253 152 254 153 255 154 256 155 257 156 258 157 259 158 260 159 261 160 262 161 263 162 264 163 265 164 266 165 267 166 268 167 269 168 270 169 271 170 272 171 273 172 274 173 275 174 276 175 277 278 279 176 280 177 281 178 179 282 180 181 182 283 183 284 184 285 185 286 186 287 187 288 289 188 290 189 291 190 292 191 293 192 294 193 194 295 195 196 296 197 297 298 299 198 
Task2 Done
301 199 302 
Task1 Done
303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 
Task3 Done

Main Done
```

##### Snippet-01 说明

我们定义了一个`Task1`类来表示子任务，这个类中定义了`run()`方法。虽然我们在`main()`方法中创建了它的一个线程，但我们似乎没有以任何方式调用`run()`方法。这里发生了什么呢？

可以通过调用名为`start()`的通用方法来创建和使用线程。调用`start()`方法将会调用线程的`run()`方法。

通过控制台输出，我们看到*Task1*的输出与标记为*Task2*和*Task3*任务的输出重叠。运行`Task1`线程和运行`Task2`，`Task3`的主线程并行运行。

#### 总结

在这一节中，我们：

- 发现了如何通过继承`Thread`类来定义子线程类
- 演示了如何运行线程

### 02：并行任务 - 实现 Runnable

##### Snippet-01：实现Runnable

在**小节01**中，我们告诉你在Java程序中线程有两种方式表示子任务。一种方式是继承`Thread`，另一种方式是实现`Runnable`接口。我们刚才看到了第一种方式，现在是时候探索第二种方式了。下面的示例向你展示是如何实现的。

***ThreadBasicsRunner.java***

```java
class Task1 extends Thread {
  public void run() {
    System.out.println("Task1 Started ");
    for(int i=101; i<=199; i++) {
      System.out.print(i + " ");
    }
    System.out.println("\nTask1 Done");
  }
}

class Task2 implements Runnable {
  @Override
  public void run() {
    System.out.println("Task2 Started ");
    for(int i=201; i<=299; i++) {
      System.out.print(i + " ");		
    }
    System.out.println("\nTask2 Done");
  }
}

public class ThreadBasicsRunner {
  public static void main(String[] args) {
    System.out.print("\nTask1 Kicked Off\n");
    Task1 task1 = new Task1();
    task1.start();

    System.out.print("\nTask2 Kicked Off\n");
    Task2 task2 = new Task2();
    Thread task2Thread = new Thread(task2);
    task2Thread.start();

    System.out.print("\nTask3 Kicked Off\n");
    for(int i=301; i<=399; i++) {
      System.out.print(i + " ");
    }
    System.out.println("\nTask3 Done");

    System.out.println("\nMain Done");
  }
}
```

***控制台输出***

```
Task1 Kicked Off
Task1 Started 
101 102 103 104 105 106 107 108 109 110 111 
Task2 Kicked Off
112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 
Task1 Done

Task3 Kicked Off
Task2 Started 
201 202 203 204 205 206 207 208 209 210 211 212 213 301 214 215 216 217 218 302 219 220 221 222 223 224 225 226 227 228 303 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 304 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 305 287 288 289 290 291 292 293 294 295 296 297 298 299 
Task2 Done
306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 
Task3 Done

Main Done
```

##### Snippet-01 说明

在本示例中，我们通过实现`Runnable`接口中的`run()`方法实现了`Runnable`接口。

为了运行已实现`Runnable`接口的`Task2`，我们使用了下面的代码。我们将`Task2`类的实例传递给了`Thread`构造器。

```java
Task2 task2 = new Task2();
Thread task2Thread = new Thread(task2);
task2Thread.start();
```

你可以从输出结果看出所有的三个任务都是并行运行的。

#### 总结

在这一节中，我们：

- 学习了另外一种创建线程的方式，通过实现`Runnable`接口
- 学习了运行使用`Runnable`接口创建的线程

